package main

import (
	"bytes"
	"flag"
	"fmt"
	"github.com/BurntSushi/toml"
	"github.com/asaskevich/govalidator"
	"log"
	"math/rand"
	"os"
	"strings"
	"time"
)

var conf *config
var softErrorCount = 0
var globalPacketCache string

func init() {
	rand.Seed(time.Now().UnixNano())
}

func main() {
	var err error
	var configPath = flag.String("config", "config.toml", "config file")
	var outputPath = flag.String("output", "-", "output file")
	var isInsideDocker = flag.Bool("docker", false, "special treatment when running inside official docker container")
	flag.Parse()

	var outputFile = os.Stdout
	if *outputPath != "-" {
		outputFile, err = os.Create(*outputPath)
		check(err)
		defer outputFile.Close()
	}

	conf = &config{}
	metaData, err := toml.DecodeFile(*configPath, conf)
	check(err)

	// print unknown configs
	for _, key := range metaData.Undecoded() {
		log.Printf("Warning: unknown option %q", key.String())
	}

	// normalize config and insert default value
	if len(conf.Listen) == 0 {
		conf.Listen = []string{"127.0.0.1:53", "[::1]:53"}
	}
	if conf.ECS.DefaultPrefixV4 == 0 {
		conf.ECS.DefaultPrefixV4 = 24
	}
	if conf.ECS.DefaultPrefixV6 == 0 {
		conf.ECS.DefaultPrefixV6 = 48
	}
	if conf.Cache.MaxEntries == 0 {
		conf.Cache.MaxEntries = 2048
	}
	if conf.Cache.MaxLifetime == 0 {
		conf.Cache.MaxLifetime = 86400
	}

	// docker config
	if *isInsideDocker {
		conf.Listen = []string{"0.0.0.0:53", "[::]:53"}
		conf.WebServer.Listen = "0.0.0.0:80"
	}

	// program identity
	log.Printf("%s %s\n%s\n", appName, appVersion, appUrl)
	_, err = fmt.Fprintf(outputFile, "%s Auto generated by %s %s\n", OutputCommentPrefix, appName, appVersion)
	check(err)
	_, err = fmt.Fprintf(outputFile, "%s %s\n", OutputCommentPrefix, appUrl)
	check(err)

	// time
	_, err = fmt.Fprintf(outputFile, "%s generated at %s\n", OutputCommentPrefix, time.Now().Format("2006-01-02 15:04:05"))
	check(err)

	// generate global config
	_, err = fmt.Fprint(outputFile, globalConfigPrependString)
	check(err)

	// control socket
	if len(conf.ControlSocket.Listen) > 0 {
		_, err = fmt.Fprintf(outputFile, "%s control socket\ncontrolSocket(\"%s\")\nsetKey(\"%s\")\n",
			OutputCommentPrefix,
			conf.ControlSocket.Listen,
			conf.ControlSocket.Key,
		)
		check(err)
	}

	// web server
	if len(conf.WebServer.Listen) > 0 {
		_, err = fmt.Fprintf(outputFile, "\n%s Web server\nwebserver(\"%s\", \"%s\", \"%s\")\n",
			OutputCommentPrefix,
			conf.WebServer.Listen,
			conf.WebServer.Password,
			conf.WebServer.ApiKey,
		)
		check(err)
	}

	// listen
	_, err = fmt.Fprintf(outputFile, "\n%s Listen\n", OutputCommentPrefix)
	check(err)
	for _, addr := range conf.Listen {
		_, err = fmt.Fprintf(outputFile, "addLocal(\"%s\")\n", addr)
		check(err)
	}

	// ACL
	_, err = fmt.Fprintf(outputFile, "\n%s ACL\nsetACL({\n", OutputCommentPrefix)
	check(err)
	for index, addr := range conf.AllowedClientSubnets {
		if index > 0 {
			_, err = fmt.Fprint(outputFile, ", \n")
			check(err)
		}
		_, err = fmt.Fprintf(outputFile, "    \"%s\"", addr)
		check(err)
	}
	_, err = fmt.Fprint(outputFile, "\n})\n")
	check(err)

	// ECS https://dnsdist.org/advanced/ecs.html
	if conf.ECS.Enabled {
		_, err = fmt.Fprintf(outputFile, `
%s EDNS0 Client Subnet
setECSSourcePrefixV4(%d)
setECSSourcePrefixV6(%d)
`,
			OutputCommentPrefix,
			conf.ECS.DefaultPrefixV4,
			conf.ECS.DefaultPrefixV6,
		)
		check(err)
	}

	// default DNS servers
	_, err = fmt.Fprintf(outputFile, "\n%s default upstream\n", OutputCommentPrefix)
	check(err)
	for _, addr := range conf.Upstreams {
		_, err = fmt.Fprintf(outputFile, "newServer(\"%s\")\n", addr)
		check(err)
	}

	// disable RFC2136 DNS update
	if !conf.AllowDDNSUpdates {
		_, err = fmt.Fprintf(outputFile, `
%s disallow RFC2136 DNS update
addAction(OpcodeRule(DNSOpcode.Update), RCodeAction(dnsdist.REFUSED))
`, OutputCommentPrefix)
		check(err)
	}

	// global cache
	if conf.Cache.Enabled {
		globalPacketCache = createCache("", conf.Cache, outputFile)
		assignCache("", globalPacketCache, outputFile)
	}

	// hosts
	log.Printf("Hosts count: %d", len(conf.ExplicitEntries))
	_, err = fmt.Fprintf(outputFile, "\n\n%s Hosts\n", OutputCommentPrefix)
	check(err)
	for key, value := range conf.ExplicitEntries {
		var v []string
		switch t := value.(type) {
		case []interface{}:
			v = emptyInterfaceToStringArray(value)
		case string:
			v = []string{value.(string)}
		default:
			e := fmt.Errorf("unknown hosts value type %s", t)
			softFail(e)
			continue
		}

		isCname := false

		for _, val := range v {
			if !govalidator.IsIP(val) {
				if isCname {
					// error: multiple CNAME entries
					e := fmt.Errorf("multiple CNAME entries for host %s", key)
					softFail(e)
				} else {
					isCname = true
				}
			}
		}

		if isCname {
			_, err = fmt.Fprintf(outputFile, "addAction(\"%s\", SpoofCNAMEAction(\"%s\"))\n\n", key, v[0])
			check(err)
		} else {
			// we need to go through key, v here
			_, err = fmt.Fprintf(outputFile, "addAction(\"%s\", SpoofAction({\n", key)
			check(err)

			for _, dst := range v {
				_, err = fmt.Fprintf(outputFile, "\t\"%s\",\n", dst)
				check(err)
			}

			_, err = fmt.Fprintf(outputFile, "}))\n\n")
			check(err)
		}
	}

	// server pools
	_, err = fmt.Fprint(outputFile, "\n\n")
	check(err)

	log.Printf("Pools count: %d", len(conf.Pools))
	for index, m := range conf.Pools {
		_, err = fmt.Fprintf(outputFile, "\n%s Pool #%d [%s]\n", OutputCommentPrefix, index+1, m.Name)
		generateServerPool(m, outputFile)
		_, err = fmt.Fprintf(outputFile, "\n%s end pool #%d [%s]\n\n", OutputCommentPrefix, index+1, m.Name)
	}

	// matches
	_, err = fmt.Fprint(outputFile, "\n\n")
	check(err)

	log.Printf("Match list count: %d", len(conf.Matches))
	for index, m := range conf.Matches {
		// normalize options and process default options
		if m["provider"] == nil {
			m["provider"] = "DomainList"
		}
		if m["action"] == nil {
			m["action"] = "resolve"
		} else {
			m["action"] = strings.ToLower(m["action"].(string))
		}

		var o bytes.Buffer

		// find the appropriate provider
		providerName := strings.ToLower(m["provider"].(string))
		found := false
		for key, value := range providers {
			if strings.ToLower(key) == providerName {
				// got a match
				log.Printf("Processing match #%d, type %s, action %s\n", index+1, key, m["action"])
				found = true
				value(index, m, &o)
				_, err = fmt.Fprintf(outputFile, "\n%s match #%d [%s] -> %s\n", OutputCommentPrefix, index+1, m["provider"], m["action"])
				check(err)
				_, err = outputFile.WriteString(o.String())
				check(err)
				_, err = fmt.Fprintf(outputFile, "\n%s end match #%d\n\n", OutputCommentPrefix, index+1)
				check(err)
				break
			}
		}

		if !found {
			log.Fatalf("Unknown provider %s at match #%d\n", m["provider"], index+1)
		}

	}

	if softErrorCount == 0 {
		log.Print("Generation successful")
	} else {
		log.Printf("Generation partially successful with %d errors", softErrorCount)
	}
}
